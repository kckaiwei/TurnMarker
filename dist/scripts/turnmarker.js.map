{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/chatter.js","webpack:///./src/scripts/marker.js","webpack:///./src/scripts/markeranimation.js","webpack:///./src/scripts/settings.js","webpack:///./src/scripts/settingsForm.js","webpack:///./src/scripts/turnmarker.js","webpack:///./src/scripts/updateWindow.js","webpack:///./src/scripts/utils.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Chatter","combatant","hideNPC_name","players","forEach","player","push","length","combatantName","actor","hasPlayerOwner","ChatMessage","speaker","content","this","placeImage","join","getIncludeAnnounceImage","img","flags","core","thumb","Marker","tokenId","markerId","moveMarkerToToken","clearAllMarkers","getTurnMarkerEnabled","token","dims","getRatio","getImageDimensions","center","getImageLocation","newTile","Tile","getImagePath","width","w","height","h","x","y","z","rotation","hidden","data","locked","turnMarker","canvas","scene","createEmbeddedEntity","_id","tile","getEmbeddedCollection","startMarker","deleteEmbeddedEntity","getStartMarkerEnabled","getStartMarker","game","user","isGM","setFlag","startMarkerPlaced","socket","emit","placeStartMarker","tileData","updateEmbeddedEntity","tiles","placeables","find","id","animator","stopAnimation","ignoreRatio","ratio","newWidth","newHeight","grid","type","newX","newY","MarkerAnimation","tileId","getEmbeddedEntity","animateRotation","app","ticker","add","remove","dt","delta","getInterval","err","imageTitles","announcedActorOptions","Settings","settings","val","set","trim","getImageByIndex","index","registerMenu","label","icon","restricted","register","default","String","scope","hint","config","Number","Boolean","choices","onChange","updateImagePath","videos","SettingsForm","FormApplication","options","super","mergeObject","defaultOptions","title","template","classes","closeOnSubmit","turnMarkerEnabled","image","getSelectList","getImageIndex","announceActors","getAnnounceActors","customImage","getCustomImagePath","announce","shouldAnnounceTurns","announceImage","startMarkerEnabled","startMarkerPath","getStartMarkerPath","previewPath","e","console","log","setRatio","setImage","setCustomImagePath","setShouldAnnounceTurns","setAnnounceActors","setIncludeAnnounceImage","setTurnMarkerEnabled","setStartMarkerEnabled","setStartMarkerPath","html","activateListeners","markerSelect","markerImgPreview","updatePreview","on","event","attr","target","markerVideoPreview","disabled","removeClass","addClass","ext","getExtension","warn","includes","toLowerCase","filePath","slice","lastIndexOf","array","selected","lastTurn","Hooks","async","registerSettings","marker","zIndex","Math","max","map","parent","sortChildren","paused","getShouldAnimate","startAnimation","isNewerVersion","version","getVersion","combat","turn","getFlag","update","userId","result","placeTurnMarker","undefined","deleteStartMarker","unsetFlag","sendTurnMessage","updateToken","updateData","tokenVision","tokens","visible","sight","testVisibility","tolerance","dimensions","size","isPaused","renderUpdateWindow","UpdateWindow","Application","resizable","ev","setVersion","currentTarget","checked","oldVersion","render","modName","FlagScope","Flags","socketName","socketAction","findTokenById","ownedTokens","firstGM","users","entities","role","active"],"mappings":"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","file":"turnmarker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"modules/turnmarker/scripts/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/scripts/turnmarker.js\");\n","import { Settings } from \"./settings.js\";\r\n\r\nexport class Chatter {\r\n\r\n    static sendTurnMessage(combatant, hideNPC_name=false) {\r\n        let players = [];\r\n        combatant.players.forEach(player => {\r\n            players.push(player.name);\r\n        });\r\n        if (players.length == 0) players.push(\"GM\");\r\n        let combatantName = combatant.name;\r\n        if (hideNPC_name && !combatant.actor.hasPlayerOwner) {\r\n            combatantName = \"???\";\r\n        }\r\n\r\n        ChatMessage.create({\r\n            speaker: { actor: combatant.actor },\r\n            //speaker: { actor: {}, alias: 'Turn Marker' },\r\n            content:\r\n                `<div class=\"flexrow\">${this.placeImage(combatant)}\r\n                    <div style=\"flex: 12;\">\r\n                        <h2>${combatantName}'s Turn</h2>\r\n                        <p>${players.join(' - ')}</p>\r\n                    </div>\r\n                    </div><em>Turn Marker</em>`\r\n        });\r\n    }\r\n\r\n    static placeImage(combatant) {\r\n        if (Settings.getIncludeAnnounceImage()) {\r\n            let img = combatant.img;\r\n            if (combatant.flags.core && combatant.flags.core.thumb) {\r\n                img = combatant.flags.core.thumb;\r\n            }\r\n            return `<div style=\"flex:3;\"><img src=\"${img}\" style=\"border: none;\" /></div>`;\r\n            // return `<div style=\"flex:3;\"><video><source=\"${combatant.img}\"></video></div>`;\r\n        } else return '';\r\n    }\r\n}","import { MarkerAnimation } from './markeranimation.js';\r\nimport { Settings } from './settings.js';\r\nimport { findTokenById, Flags, FlagScope, socketAction, socketName } from './utils.js';\r\n\r\n/**\r\n * Provides functionality for creating, moving, and animating the turn marker\r\n */\r\nexport class Marker {\r\n\r\n    /**\r\n     * Places a new turn marker under the token specified, and if required, starts the animation\r\n     * @param {String} tokenId - The ID of the token where the marker should be placed\r\n     * @param {Object} animator - The animator object\r\n     * @param {String} markerId - The ID of the tile being used as the turn marker\r\n     */\r\n    static async placeTurnMarker(tokenId, markerId) {\r\n        if (!markerId) {\r\n            this.clearAllMarkers();\r\n\r\n            if (Settings.getTurnMarkerEnabled()) {\r\n                let token = findTokenById(tokenId);\r\n                let ratio = Settings.getRatio();\r\n                let dims = this.getImageDimensions(token);\r\n                let center = this.getImageLocation(token);\r\n\r\n                let newTile = new Tile({\r\n                    img: Settings.getImagePath(),\r\n                    width: dims.w,\r\n                    height: dims.h,\r\n                    x: center.x,\r\n                    y: center.y,\r\n                    z: 900,\r\n                    rotation: 0,\r\n                    hidden: token.data.hidden,\r\n                    locked: false,\r\n                    flags: { turnMarker: true }\r\n                });\r\n\r\n                let tile = await canvas.scene.createEmbeddedEntity('Tile', newTile.data);\r\n\r\n                return tile._id;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            this.moveMarkerToToken(tokenId, markerId);\r\n            return markerId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes any tiles flagged as a 'Start Marker' from the canvas\r\n     */\r\n    static async deleteStartMarker() {\r\n        for (var tile of canvas.scene.getEmbeddedCollection('Tile')) {\r\n            if (tile.flags.startMarker) {\r\n                await canvas.scene.deleteEmbeddedEntity('Tile', tile._id);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If enabled in settings, place a \"start\" marker under the token where their turn started.\r\n     * @param {String} tokenId - The ID of the token to place the start marker under\r\n     */\r\n    static async placeStartMarker(tokenId) {\r\n        if (Settings.getStartMarkerEnabled()) {\r\n            let token = findTokenById(tokenId);\r\n            let dims = this.getImageDimensions(token);\r\n            let center = this.getImageLocation(token);\r\n            let newTile = new Tile({\r\n                img: Settings.getStartMarker(),\r\n                width: dims.w,\r\n                height: dims.h,\r\n                x: center.x,\r\n                y: center.y,\r\n                z: 900,\r\n                rotation: 0,\r\n                hidden: token.data.hidden,\r\n                locked: false,\r\n                flags: { startMarker: true }\r\n            });\r\n\r\n            if (game.user.isGM) {\r\n                canvas.scene.createEmbeddedEntity('Tile', newTile.data);\r\n                canvas.scene.setFlag(FlagScope, Flags.startMarkerPlaced, true);\r\n            } else {\r\n                game.socket.emit(socketName, {\r\n                    mode: socketAction.placeStartMarker,\r\n                    tileData: newTile.data\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the turn marker tile under the specified token\r\n     * @param {String} tokenId - The ID of the token that the marker should be placed under\r\n     * @param {String} markerId - The ID of the tile currently serving as the turn marker\r\n     */\r\n    static async moveMarkerToToken(tokenId, markerId) {\r\n        let token = findTokenById(tokenId);\r\n        let ratio = Settings.getRatio();\r\n        let dims = this.getImageDimensions(token);\r\n        let center = this.getImageLocation(token);\r\n\r\n        await canvas.scene.updateEmbeddedEntity('Tile', {\r\n            _id: markerId,\r\n            width: dims.w,\r\n            height: dims.h,\r\n            x: center.x,\r\n            y: center.y,\r\n            hidden: token.data.hidden\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes any existing turn marker and start marker tiles from the canvas\r\n     */\r\n    static async clearAllMarkers() {\r\n        let tiles = canvas.scene.getEmbeddedCollection('Tile');\r\n\r\n        for (var tile of tiles) {\r\n            if (tile.flags.turnMarker || tile.flags.startMarker) {\r\n                await canvas.scene.deleteEmbeddedEntity('Tile', tile._id);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the tile image when the image path has changed\r\n     */\r\n    static updateImagePath() {\r\n        if (game.user.isGM) {\r\n            let tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n            if (tile) {\r\n                canvas.scene.updateEmbeddedEntity('Tile', {\r\n                    _id: tile.id,\r\n                    img: Settings.getImagePath()\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Completely resets the turn marker - deletes all tiles and stops any animation\r\n     * @param {Object} animator - The animator object\r\n     */\r\n    static reset(animator) {\r\n        MarkerAnimation.stopAnimation(animator);\r\n        this.clearAllMarkers();\r\n    }\r\n\r\n    /**\r\n     * Gets the proper dimensions of the marker tile taking into account the current grid layout\r\n     * @param {object} token - The token that the tile should be placed under\r\n     */\r\n    static getImageDimensions(token, ignoreRatio = false) {\r\n        let ratio = ignoreRatio ? 1 : Settings.getRatio();\r\n        let newWidth = 0;\r\n        let newHeight = 0;\r\n\r\n        switch (canvas.grid.type) {\r\n            case 2: case 3: // Hex Rows\r\n                newWidth = newHeight = token.h * ratio;\r\n                break;\r\n            case 4: case 5: // Hex Columns\r\n                newWidth = newHeight = token.w * ratio;\r\n                break;\r\n            default: // Gridless and Square\r\n                newWidth = token.w * ratio;\r\n                newHeight = token.h * ratio;\r\n                break;\r\n        }\r\n\r\n        return { w: newWidth, h: newHeight };\r\n    }\r\n\r\n    /**\r\n     * Gets the proper location of the marker tile taking into account the current grid layout\r\n     * @param {object} token - The token that the tile should be placed under\r\n     */\r\n    static getImageLocation(token, ignoreRatio = false) {\r\n        let ratio = ignoreRatio ? 1 : Settings.getRatio();\r\n        let newX = 0;\r\n        let newY = 0;\r\n\r\n        switch (canvas.grid.type) {\r\n            case 2: case 3: // Hex Rows\r\n                newX = token.center.x - ((token.h * ratio) / 2);\r\n                newY = token.center.y - ((token.h * ratio) / 2);\r\n                break;\r\n            case 4: case 5: // Hex Columns\r\n                newX = token.center.x - ((token.w * ratio) / 2);\r\n                newY = token.center.y - ((token.w * ratio) / 2);\r\n                break;\r\n            default: // Gridless and Square\r\n                newX = token.center.x - ((token.w * ratio) / 2);\r\n                newY = token.center.y - ((token.h * ratio) / 2);\r\n        }\r\n\r\n        return { x: newX, y: newY };\r\n    }\r\n}","import { Settings } from './settings.js';\r\n\r\nexport class MarkerAnimation {\r\n    /**\r\n     * Starts the animation loop for the specified tile\r\n     * @param {object} animator - The animator object\r\n     * @param {String} tileId - The ID of the tile currently serving as the turn marker \r\n     */\r\n    static startAnimation(animator, tileId) {\r\n        let tile = canvas.scene.getEmbeddedEntity('Tile', tileId);\r\n        animator = this.animateRotation.bind(tile);\r\n        canvas.app.ticker.add(animator);\r\n        return animator;\r\n    }\r\n\r\n    /**\r\n     * Stops the animation loop for the specified tile\r\n     * @param {object} animator - The animator object\r\n     */\r\n    static stopAnimation(animator) {\r\n        canvas.app.ticker.remove(animator);\r\n    }\r\n\r\n    /**\r\n     * Called on every tick of the animation loop to rotate the image based on the current frame\r\n     * @param {number} dt - The delta time\r\n     */\r\n    static animateRotation(dt) {\r\n        let tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n        if (tile && tile.data.img) {\r\n            let delta = Settings.getInterval() / 10000;\r\n            try {\r\n                tile.tile.img.rotation += (delta * dt);\r\n            } catch (err) {\r\n                // skip lost frames if the tile is being updated by the server\r\n            }\r\n        }\r\n    }\r\n}","import { Marker } from './marker.js';\r\nimport { SettingsForm } from './settingsForm.js';\r\nimport { modName } from './utils.js';\r\n\r\nconst version = 'tm-version';\r\nconst ratio = 'ratio';\r\nconst animation = 'animation';\r\nconst interval = 'interval';\r\nconst announce = 'announce-turn';\r\nconst announceActors = 'announce-Actors';\r\nconst announceAsActor = 'announce-asActor';\r\nconst announceImage = 'announce-image';\r\nconst image = 'image';\r\nconst customimage = 'customimage';\r\nconst turnMarkerEnabled = 'turnmarker-enabled';\r\nconst startMarkerEnabled = 'startMarker-enabled';\r\nconst startMarkerImage = 'startMarker-custom';\r\nexport const imageTitles = [\r\n    'Runes of Incendium by Rin',\r\n    'Runes of the Cultist by Rin',\r\n    'Runes of Regeneration by Rin',\r\n    'Runes of the Cosmos by Rin',\r\n    'Runes of Earthly Dust by Rin',\r\n    'Runes of Reality by Rin',\r\n    'Runes of the Believer by Rin',\r\n    'Runes of the Mad Mage by Rin',\r\n    'Runes of the Blue Sky by Rin',\r\n    'Runes of the Universe by Rin',\r\n    'Runes of Prosperity by Rin'\r\n];\r\n\r\nexport const announcedActorOptions = [\r\n    'Announce for all',\r\n    'Announce for players',\r\n    'Announce for GM-controlled',\r\n    'Announce all but hide GM-controlled names'\r\n];\r\n\r\n/**\r\n * Provides functionality for reading and writing module settings\r\n */\r\nexport class Settings {\r\n\r\n    static getVersion() {\r\n        return game.settings.get(modName, version);\r\n    }\r\n\r\n    static setVersion(val) {\r\n        game.settings.set(modName, version, val);\r\n    }\r\n\r\n    /**\r\n     * Gets the image ratio\r\n     */\r\n    static getRatio() {\r\n        return game.settings.get(modName, ratio);\r\n    }\r\n\r\n    /**\r\n     * Sets the image ratio\r\n     * @param {Number} val - The image ratio\r\n     */\r\n    static setRatio(val) {\r\n        game.settings.set(modName, ratio, val);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the marker should be animated\r\n     */\r\n    static getShouldAnimate() {\r\n        return game.settings.get(modName, animation);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation interval in ms.\r\n     */\r\n    static getInterval() {\r\n        return game.settings.get(modName, interval);\r\n    }\r\n\r\n    /**\r\n     * Returns true if turn changes should be announced in chat\r\n     */\r\n    static shouldAnnounceTurns() {\r\n        return game.settings.get(modName, announce);\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not to announce turn changes\r\n     * @param {Boolean} val - Whether or not to announce turn changes\r\n     */\r\n    static setShouldAnnounceTurns(val) {\r\n        game.settings.set(modName, announce, val);\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets index of setting\r\n     * @returns {Number} - Index number of announced\r\n     */\r\n    static getAnnounceActors() {\r\n        return game.settings.get(modName, announceActors);\r\n    }\r\n\r\n    /**\r\n     * Sets who sees announced turn changes\r\n     * @param announceActors - which owners get units announcedActorOptions, which is selected.\r\n     */\r\n    static setAnnounceActors(val) {\r\n        return game.settings.set(modName, announceActors, val);\r\n    }\r\n\r\n    static getIncludeAnnounceImage() {\r\n        return game.settings.get(modName, announceImage);\r\n    }\r\n\r\n    static setIncludeAnnounceImage(val) {\r\n        game.settings.set(modName, announceImage, val);\r\n    }\r\n\r\n    /**\r\n     * Gets the index of the currently selected marker image\r\n     */\r\n    static getImageIndex() {\r\n        return game.settings.get(modName, image);\r\n    }\r\n\r\n    static getStartMarker() {\r\n        if (game.settings.get(modName, startMarkerImage).trim() == '') {\r\n            return 'modules/turnmarker/assets/start.png';\r\n        } else {\r\n            return game.settings.get(modName, startMarkerImage);\r\n        }\r\n    }\r\n\r\n    static getTurnMarkerEnabled() {\r\n        return game.settings.get(modName, turnMarkerEnabled);\r\n    }\r\n\r\n\r\n    static setTurnMarkerEnabled(val) {\r\n        game.settings.set(modName, turnMarkerEnabled, val);\r\n    }\r\n\r\n    static getStartMarkerEnabled() {\r\n        return game.settings.get(modName, startMarkerEnabled);\r\n    }\r\n\r\n    static setStartMarkerEnabled(val) {\r\n        game.settings.set(modName, startMarkerEnabled, val);\r\n    }\r\n\r\n    static getStartMarkerPath() {\r\n        return game.settings.get(modName, startMarkerImage);\r\n    }\r\n\r\n    static setStartMarkerPath(val) {\r\n        game.settings.set(modName, startMarkerImage, val);\r\n    }\r\n\r\n    /**\r\n     * Gets a path to the currently selected image to be used as the marker\r\n     */\r\n    static getImagePath() {\r\n        if (game.settings.get(modName, customimage).trim() == '') {\r\n            return this.getImageByIndex(game.settings.get(modName, image));\r\n        } else {\r\n            return game.settings.get(modName, customimage);\r\n        }\r\n    }\r\n\r\n    static getImageByIndex(index) {\r\n        switch (index) {\r\n            case 0: return 'modules/turnmarker/assets/incendium.png';\r\n            case 1: return 'modules/turnmarker/assets/cultist.png';\r\n            case 2: return 'modules/turnmarker/assets/regeneration.png';\r\n            case 3: return 'modules/turnmarker/assets/cosmos.png';\r\n            case 4: return 'modules/turnmarker/assets/earthlydust.png';\r\n            case 5: return 'modules/turnmarker/assets/reality.png';\r\n            case 6: return 'modules/turnmarker/assets/believer.png';\r\n            case 7: return 'modules/turnmarker/assets/madmage.png';\r\n            case 8: return 'modules/turnmarker/assets/bluesky.png';\r\n            case 9: return 'modules/turnmarker/assets/universe.png';\r\n            case 10: return 'modules/turnmarker/assets/prosperity.png';\r\n        }\r\n    }\r\n\r\n    static setImage(val) {\r\n        game.settings.set(modName, image, val);\r\n    }\r\n\r\n    static getCustomImagePath() {\r\n        return game.settings.get(modName, customimage);\r\n    }\r\n\r\n    static setCustomImagePath(val) {\r\n        game.settings.set(modName, customimage, val);\r\n    }\r\n\r\n    /**\r\n     * Registers all game settings\r\n     */\r\n    static registerSettings() {\r\n\r\n        game.settings.registerMenu(modName, 'tm.settingsMenu', {\r\n            name: 'tm.settings.button.name',\r\n            label: 'tm.settings.button.label',\r\n            icon: 'fas fa-sync-alt',\r\n            type: SettingsForm,\r\n            restricted: true,\r\n        });\r\n\r\n        game.settings.register(modName, version, {\r\n            name: `${modName} version`,\r\n            default: '0.0.0',\r\n            type: String,\r\n            scope: 'world',\r\n        });\r\n\r\n        game.settings.register(modName, ratio, {\r\n            name: 'tm.settings.ratio.name',\r\n            hint: 'tm.settings.ratio.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Number,\r\n            default: 1.5,\r\n            restricted: true\r\n        });\r\n\r\n        game.settings.register(modName, animation, {\r\n            name: 'tm.settings.animate.name',\r\n            hint: 'tm.settings.animate.hint',\r\n            scope: 'user',\r\n            config: true,\r\n            type: Boolean,\r\n            default: true,\r\n        });\r\n\r\n        game.settings.register(modName, interval, {\r\n            name: 'tm.settings.interval.name',\r\n            hint: 'tm.settings.interval.hint',\r\n            scope: 'user',\r\n            config: true,\r\n            type: Number,\r\n            default: 100\r\n        });\r\n\r\n        game.settings.register(modName, image, {\r\n            name: 'tm.settings.image.name',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Number,\r\n            default: 0,\r\n            choices: imageTitles,\r\n            restricted: true,\r\n            onChange: value => Marker.updateImagePath(value)\r\n        });\r\n\r\n        game.settings.register(modName, announceActors, {\r\n            name: 'tm.settings.announcedActors.name',\r\n            hint: 'tm.settings.announcedActors.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Number,\r\n            default: 0,\r\n            restricted: true,\r\n            choices: announcedActorOptions,\r\n        });\r\n\r\n        game.settings.register(modName, customimage, {\r\n            name: 'tm.settings.customImage.name',\r\n            hint: 'tm.settings.customImage.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: String,\r\n            default: '',\r\n            restricted: true,\r\n            onChange: value => Marker.updateImagePath(value)\r\n        });\r\n\r\n        game.settings.register(modName, announce, {\r\n            name: 'tm.settings.announce.name',\r\n            hint: 'tm.settings.announce.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Boolean,\r\n            default: true\r\n        });\r\n\r\n        game.settings.register(modName, announceImage, {\r\n            name: 'tm.settings.announceImage.name',\r\n            hint: 'tm.settings.announceImage.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Boolean,\r\n            default: true\r\n        });\r\n\r\n        game.settings.register(modName, announceAsActor, {\r\n            name: 'tm.settings.announceAs.name',\r\n            hint: 'tm.settings.announceAs.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Boolean,\r\n            default: true\r\n        });\r\n\r\n        game.settings.register(modName, turnMarkerEnabled, {\r\n            name: 'tm.settings.turnMarkerEnabled.name',\r\n            hint: 'tm.settings.turnMarkerEnabled.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Boolean,\r\n            default: true,\r\n            restricted: true\r\n        });\r\n\r\n        game.settings.register(modName, startMarkerEnabled, {\r\n            name: 'tm.settings.startEnabled.name',\r\n            hint: 'tm.settings.startEnabled.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: Boolean,\r\n            default: false,\r\n            restricted: true\r\n        });\r\n\r\n        game.settings.register(modName, startMarkerImage, {\r\n            name: 'tm.settings.startImage.name',\r\n            hint: 'tm.settings.startImage.hint',\r\n            scope: 'world',\r\n            config: false,\r\n            type: String,\r\n            default: '',\r\n            restricted: true\r\n        });\r\n    }\r\n}","import { imageTitles, announcedActorOptions, Settings } from './settings.js';\r\n\r\nconst videos = ['mp4', 'webm', 'ogg'];\r\n\r\nexport class SettingsForm extends FormApplication {\r\n\r\n    constructor(object, options = {}) {\r\n        super(object, options);\r\n    }\r\n\r\n    /**\r\n    * Default Options for this FormApplication\r\n    */\r\n    static get defaultOptions() {\r\n        return mergeObject(super.defaultOptions, {\r\n            id: 'turnmarker-settings-form',\r\n            title: 'Turn Marker - Global Settings',\r\n            template: './modules/turnmarker/templates/settings.html',\r\n            classes: ['sheet', 'tm-settings'],\r\n            width: 500,\r\n            closeOnSubmit: true\r\n        });\r\n    }\r\n\r\n    getData() {\r\n        return {\r\n            turnMarkerEnabled: Settings.getTurnMarkerEnabled(),\r\n            ratio: Settings.getRatio(),\r\n            image: this.getSelectList(imageTitles, Settings.getImageIndex()),\r\n            announceActors: this.getSelectList(announcedActorOptions, Settings.getAnnounceActors()),\r\n            customImage: Settings.getCustomImagePath(),\r\n            announce: Settings.shouldAnnounceTurns(),\r\n            announceImage: Settings.getIncludeAnnounceImage(),\r\n            startMarkerEnabled: Settings.getStartMarkerEnabled(),\r\n            startMarkerPath: Settings.getStartMarkerPath(),\r\n            previewPath: Settings.getImagePath()\r\n        };\r\n    }\r\n\r\n    /** \r\n     * Executes on form submission.\r\n     * @param {Object} e - the form submission event\r\n     * @param {Object} d - the form data\r\n     */\r\n    async _updateObject(e, d) {\r\n        console.log('Turn Marker | Saving Settings');\r\n        Settings.setRatio(d.ratio);\r\n        if (d.image) Settings.setImage(d.image);\r\n        Settings.setCustomImagePath(d.customImage);\r\n        Settings.setShouldAnnounceTurns(d.announce);\r\n        Settings.setAnnounceActors(d.announceActors);\r\n        Settings.setIncludeAnnounceImage(d.announceImage);\r\n        Settings.setTurnMarkerEnabled(d.turnMarkerEnabled);\r\n        Settings.setStartMarkerEnabled(d.startMarkerEnabled);\r\n        Settings.setStartMarkerPath(d.startMarkerPath);\r\n    }\r\n\r\n    activateListeners(html) {\r\n        super.activateListeners(html);\r\n        const markerSelect = html.find('#image');\r\n        const customImage = html.find('#customImage');\r\n        const markerImgPreview = html.find('#markerImgPreview');\r\n\r\n        this.updatePreview(html);\r\n\r\n        if (markerSelect.length > 0) {\r\n            markerSelect.on('change', event => {\r\n                if (customImage[0].value.trim() == '') {\r\n                    markerImgPreview.attr('src', Settings.getImageByIndex(Number(event.target.value)));\r\n                }\r\n            });\r\n        }\r\n\r\n        if (customImage.length > 0) {\r\n            customImage.on('change', event => {\r\n                this.updatePreview(html);\r\n            });\r\n        }\r\n    }\r\n\r\n    updatePreview(html) {\r\n        const markerSelect = html.find('#image');\r\n        const customImage = html.find('#customImage');\r\n        const markerImgPreview = html.find('#markerImgPreview');\r\n        const markerVideoPreview = html.find('#markerVideoPreview');\r\n\r\n        if (customImage[0].value.trim() == '') {\r\n            markerSelect[0].disabled = false;\r\n            markerImgPreview.attr('src', Settings.getImageByIndex(Number(markerSelect[0].value)));\r\n            markerImgPreview.removeClass('hidden');\r\n            markerVideoPreview.addClass('hidden');\r\n        } else {\r\n            markerSelect[0].disabled = true;\r\n            const ext = this.getExtension(customImage[0].value);\r\n            console.warn(ext);\r\n            if (videos.includes(ext.toLowerCase())) {\r\n                markerVideoPreview.attr('src', customImage[0].value);\r\n                markerImgPreview.addClass('hidden');\r\n                markerVideoPreview.removeClass('hidden');\r\n            } else {\r\n                markerImgPreview.attr('src', customImage[0].value);\r\n                markerImgPreview.removeClass('hidden');\r\n                markerVideoPreview.addClass('hidden');\r\n            }\r\n        }\r\n    }\r\n\r\n    getExtension(filePath) {\r\n        return filePath.slice((filePath.lastIndexOf(\".\") - 1 >>> 0) + 2);\r\n    }\r\n\r\n    getSelectList(array, selected) {\r\n        let options = [];\r\n        array.forEach((x, i) => {\r\n            options.push({ value: x, selected: i == selected });\r\n        });\r\n        return options;\r\n    }\r\n}","import { Chatter } from './chatter.js';\r\nimport { Marker } from './marker.js';\r\nimport { MarkerAnimation } from './markeranimation.js';\r\nimport { Settings } from './settings.js';\r\nimport { renderUpdateWindow } from './updateWindow.js';\r\nimport { firstGM, Flags, FlagScope, socketAction, socketName } from './utils.js';\r\n\r\nlet animator;\r\nlet markerId;\r\nlet lastTurn = '';\r\n\r\nHooks.on('ready', async () => {\r\n    Settings.registerSettings();\r\n    let marker = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n    if (marker && marker.id) {\r\n        markerId = marker.id;\r\n        let tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n        tile.zIndex = Math.max(...canvas.tiles.placeables.map(o => o.zIndex)) + 1;\r\n        tile.parent.sortChildren();\r\n        if (!game.paused && Settings.getShouldAnimate()) {\r\n            animator = MarkerAnimation.startAnimation(animator, markerId);\r\n        }\r\n    }\r\n\r\n    if (game.user.isGM) {\r\n        if (isNewerVersion(game.modules.get(\"turnmarker\").data.version, Settings.getVersion())) {\r\n            renderUpdateWindow();\r\n        }\r\n    }\r\n\r\n    game.socket.on(socketName, async (data) => {\r\n        if (game.user.isGM) {\r\n            switch (data.mode) {\r\n                case socketAction.placeStartMarker:\r\n                    await canvas.scene.createEmbeddedEntity('Tile', data.tileData);\r\n                    canvas.scene.setFlag(FlagScope, Flags.startMarkerPlaced, true);\r\n            }\r\n        }\r\n    });\r\n});\r\n\r\nHooks.on('createTile', (scene, tile) => {\r\n    if (tile.flags.turnMarker == true) {\r\n        markerId = tile._id;\r\n        tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n        tile.zIndex = Math.max(...canvas.tiles.placeables.map(o => o.zIndex)) + 1;\r\n        tile.parent.sortChildren();\r\n        if (Settings.getShouldAnimate()) {\r\n            animator = MarkerAnimation.startAnimation(animator, markerId);\r\n        }\r\n    }\r\n});\r\n\r\nHooks.on('preUpdateToken', async (scene, token) => {\r\n    if (game.combat != null && game.combat.turn != -1) {\r\n        if (token._id == game.combat.combatant.token._id && !canvas.scene.getFlag(FlagScope, Flags.startMarkerPlaced)) {\r\n            await Marker.placeStartMarker(game.combat.combatant.token._id);\r\n        }\r\n    }\r\n});\r\n\r\nHooks.on('updateCombat', async (combat, update) => {\r\n    if (combat.combatant) {\r\n        if (update && lastTurn != combat.combatant._id && game.user.isGM && game.userId == firstGM()) {\r\n            lastTurn = combat.combatant._id;\r\n            if (combat && combat.combatant) {\r\n                let tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n                let result = await Marker.placeTurnMarker(combat.combatant.token._id, (tile && tile.id) || undefined);\r\n                if (result) {\r\n                    markerId = result.markerId;\r\n                    animator = result.animator;\r\n                }\r\n                if (Settings.getTurnMarkerEnabled()) {\r\n                    Marker.deleteStartMarker();\r\n                    canvas.scene.unsetFlag(FlagScope, Flags.startMarkerPlaced);\r\n                }\r\n                if (Settings.shouldAnnounceTurns() && !combat.combatant.hidden) {\r\n                    switch (Settings.getAnnounceActors()){\r\n                        case 0:\r\n                            Chatter.sendTurnMessage(combat.combatant);\r\n                            break;\r\n                        case 1:\r\n                            if (combat.combatant.actor.hasPlayerOwner) {\r\n                                Chatter.sendTurnMessage(combat.combatant);\r\n                            }\r\n                            break;\r\n                        case 2:\r\n                            if (!combat.combatant.actor.hasPlayerOwner) {\r\n                                Chatter.sendTurnMessage(combat.combatant);\r\n                            }\r\n                            break;\r\n                        case 3:\r\n                            Chatter.sendTurnMessage(combat.combatant, true);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nHooks.on('deleteCombat', async () => {\r\n    if (game.user.isGM) {\r\n        Marker.clearAllMarkers();\r\n    }\r\n    MarkerAnimation.stopAnimation(animator);\r\n});\r\n\r\nHooks.on('updateToken', (scene, updateToken, updateData) => {\r\n    let tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n    if (tile) {\r\n        if ((updateData.x || updateData.y || updateData.width || updateData.height || updateData.hidden) &&\r\n            (game && game.combat && game.combat.combatant && game.combat.combatant.tokenId == updateToken._id) &&\r\n            game.user.isGM && game.combat) {\r\n            Marker.moveMarkerToToken(updateToken._id, tile.id);\r\n            tile.zIndex = Math.max(...canvas.tiles.placeables.map(o => o.zIndex)) + 1;\r\n            tile.parent.sortChildren();\r\n        }\r\n    }\r\n});\r\n\r\nHooks.on('updateTile', () => {\r\n    if (canvas.scene.data.tokenVision) {\r\n        let tile = canvas.tiles.placeables.find(t => t.data.flags.turnMarker == true);\r\n        if (tile) {\r\n            let combatant = canvas.tokens.placeables.find(x => x.id == game.combat.combatant.tokenId);\r\n            if (combatant && !combatant.data.hidden) {\r\n                tile.visible = canvas.sight.testVisibility(combatant.center, { tolerance: canvas.dimensions.size / 4 });\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nHooks.on('pauseGame', async (isPaused) => {\r\n    if (markerId && Settings.getShouldAnimate()) {\r\n        if (isPaused) {\r\n            MarkerAnimation.stopAnimation(animator);\r\n        } else {\r\n            animator = MarkerAnimation.startAnimation(animator, markerId);\r\n        }\r\n    }\r\n});\r\n","import { Settings } from './settings.js';\r\n\r\nexport function renderUpdateWindow() {\r\n    const module = game.modules.get(\"turnmarker\");\r\n\r\n    if (!isNewerVersion(module.data.version, Settings.getVersion()))\r\n        return;\r\n\r\n    class UpdateWindow extends Application {\r\n        static get defaultOptions() {\r\n            return mergeObject(super.defaultOptions, {\r\n                template: `modules/${module.id}/templates/updateWindow.html`,\r\n                resizable: false,\r\n                width: 500,\r\n                height: 600,\r\n                classes: [\"updateWindow\"],\r\n                title: `${module.data.title} - Updated`\r\n            });\r\n        }\r\n\r\n        getData() {\r\n            return {\r\n                version: module.data.version\r\n            };\r\n        }\r\n\r\n        activateListeners(html) {\r\n            super.activateListeners(html);\r\n\r\n            html.find('.show-again').on('change', ev => {\r\n                Settings.setVersion(ev.currentTarget.checked ? module.data.version : oldVersion);\r\n            });\r\n        }\r\n    }\r\n\r\n    new UpdateWindow().render(true);\r\n}","\r\n/**\r\n * The name of the module\r\n */\r\nexport const modName = 'turnmarker';\r\n\r\n/*** Flag Info */\r\nexport const FlagScope = 'turnmarker';\r\nexport const Flags = {\r\n    startMarkerPlaced: 'startMarkerPlaced'\r\n};\r\n\r\n/** Socket Info */\r\nexport const socketName = 'module.turnmarker';\r\nexport const socketAction = {\r\n    placeStartMarker: 0\r\n};\r\n\r\n/**\r\n * Returns a token object from the canvas based on the ID value\r\n * @param {String} tokenId - The ID of the token to look for\r\n */\r\nexport function findTokenById(tokenId) {\r\n    return canvas.tokens.ownedTokens.find(t => t.id == tokenId);\r\n}\r\n\r\n/**\r\n * Returns the ID of the first user logged in as GM.\r\n * Use for actions that need to be done by a GM but by only 1 GM\r\n */\r\nexport function firstGM() {\r\n    for (let user of game.users.entities) {\r\n        if (user.data.role >= 4 && user.active) {\r\n            return user.data._id;\r\n        }\r\n    }\r\n    return undefined;\r\n}"],"sourceRoot":""}